<html>
<canvas id="scene"></canvas>

<body>
  <script type="module">


    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.117.1/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.124.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.129.0/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';
    var ww = window.innerWidth;
    var wh = window.innerHeight;
    var renderer;
    var camera;
    var scene;
    var light;
    var mixer;
    var controls;
    var loader4 = new THREE.TextureLoader();
    var texture = loader4.load("wood2.jpeg");




    function init() {
      /* WEBGL RENDERER */
      const canvas = document.querySelector('#scene');
      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setClearColor(0x89cff0);
      renderer.setSize(ww, wh);
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(50, ww / wh, 1, 100000);
      camera.position.set(895, 400, 2400);
      //camera.position.set(895, 400, 2200);
      camera.rotateX(-0.349066);
      camera.rotateY(3.14159);
      //camera.rotateY(0.349066);
      scene.add(camera);
      controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 5, 0);
      controls.update();
      // const spotLight = new THREE.SpotLight(0xffffff, 5, { angle: Math.PI / 2 });
      // spotLight.position.x = -1000;
      // spotLight.position.y = 1000;
      // spotLight.position.z = 1000;
      // spotLight.rotation.z = -0.6;
      // spotLight.position.set(-2000, 1500, 100);

      // spotLight.castShadow = true;

      // light = new THREE.SpotLight(0xffffff, 5);
      // light.angle = Math.PI / 10;
      // light.castShadow = true; // default false
      // light.position.x = -1500;
      // // light.position.z = 1200;
      // light.position.y = 900;
      //light.rotation.z = Math.PI;

      //scene.add(light);
      //ight.target.position = new THREE.Object3D(-1000, 0, 1200);
      //Set up shadow properties for the light
      // light.shadow.mapSize.width = 512; // default
      // light.shadow.mapSize.height = 512; // default
      // light.shadow.camera.near = 0.5; // default
      // light.shadow.camera.far = 500; // default
      // light.shadow.focus = 1; // default

      // const spotLightHelper = new THREE.SpotLightHelper(light);
      // scene.add(spotLightHelper);
      const light = new THREE.HemisphereLight(0xffffbb, 0x080820, 3);
      light.position.set(0, 50, 0);
      scene.add(light);


      // const loader = new GLTFLoader();
      // loader.load('kgirls01/scene.gltf', function (gltf) {
      //   gltf.scene.position.set(0, 100, -3000);
      //   gltf.scene.scale.set(100, 100, 100);
      //   gltf.scene.rotateY(1.5708);
      //   //gltf.scene.rotateY(0.785398);
      //   scene.add(gltf.scene);
      // });



      home();
      gameName();
      arrow();
      boy('Waving.fbx', 700, 500, 0);
      start();





    };
    init();
    var points = [];
    var x = -2000;
    var y = 1200;
    var z = 2000;

    for (var i = 0; i < 100; i++) {
      points.push(new THREE.Vector3(x, y, z));
      z -= 105;
      console.log(points[i]);
    }
    var spline = new THREE.CatmullRomCurve3(points);
    var camPosIndex = 98;
    function update() {



      if (camPosIndex <= 0) {
        return;
      }
      var camPos = spline.getPoint(camPosIndex);


      camera.position.x = camPos.x;
      camera.position.y = camPos.y;
      camera.position.z = camPos.z;
      camPosIndex--;
      renderer.render(scene, camera);
      requestAnimationFrame(update);


    }








    function home() {
      const loader = new GLTFLoader();
      loader.load('home/scene.gltf', function (gltf) {
        gltf.scene.position.set(-200, -900, -1400);
        gltf.scene.scale.set(500, 500, 500);
        gltf.scene.rotation.y = -1.22173;
        scene.add(gltf.scene);
      });
    }



    function gameName() {
      const loader1 = new THREE.FontLoader();
      loader1.load('./Open Sans_Italic.json', function (font) {
        const geometry = new THREE.TextGeometry('Treasure Hunt', {
          font: font,
          size: 100,
          height: 50,
        });
        const textMesh = new THREE.Mesh(geometry, [
          new THREE.MeshPhongMaterial({ color: 0xad4000 }),
          new THREE.MeshPhongMaterial({ color: 0x5c2301 })
        ])
        textMesh.castShadow = true;
        textMesh.position.y = 0;
        textMesh.position.z = 1200;
        textMesh.position.x = -1000;
        textMesh.rotation.y = 0.872665;
        // textMesh.add(light);
        scene.add(textMesh);

      });
    }





    function arrow() {
      const loader4 = new GLTFLoader();
      loader4.load('arrow_3d/scene.gltf', function (gltf) {
        gltf.scene.position.set(-900, 200, 600);
        gltf.scene.scale.set(30, 30, 30);
        gltf.scene.rotation.y = -2.0944;
        // gltf.scene.rotation.x = 1.5708;
        gltf.scene.rotation.z = -1.5708;
        var model = gltf.scene;
        model.traverse((o) => {
          if (o.isMesh) {
            o.material.map = texture;
          }
        });
        scene.add(model);
      });
    }


    function level1() {
      const loader2 = new GLTFLoader();
      loader2.load('garden/scene.gltf', function (gltf) {
        gltf.scene.position.set(-4500, 0, -11000);
        gltf.scene.rotation.y = 0.174533;
        gltf.scene.scale.set(300, 300, 300);
        scene.add(gltf.scene);
      });
    }


    var animation;
    function boy(action, x, z, y) {
      const loader = new FBXLoader();

      loader.load('aj.fbx', (fbx) => {
        fbx.scale.setScalar(3);
        fbx.position.x = x;
        fbx.position.z = z;
        fbx.rotation.y = y;
        fbx.traverse(c => {
          c.castShadow = true;
        });
        const anim = new FBXLoader();
        anim.load(action, (anim) => {
          mixer = new THREE.AnimationMixer(fbx);
          const idle = mixer.clipAction(anim.animations[0]);
          idle.play();
        });
        scene.add(fbx);
        var level = 0;
        document.onkeydown = function (e) {
          if (e.keyCode == 39) {
            camera.position.x += 20;
            fbx.position.x += 20;
          }
          else if (e.keyCode == 37) {
            camera.position.x -= 20;
            fbx.position.x -= 20;
          }
          else if (e.keyCode == 38) {
            camera.position.z -= 20;
            fbx.position.z -= 20;
          }
          else if (e.keyCode == 38) {
            camera.position.z -= 20;
            fbx.position.z -= 20;
          }
          else if (e.keyCode == 40) {
            camera.position.z += 20;
            fbx.position.z += 20;
          } else if (e.keyCode == 13) {
            update();
            level++;
            if (level == 1) {
              camera.rotation.x = 0.698132;
              controls.target.set(-2600, -200, -20000);
              controls.update();
              level1();
              boy('walking.fbx', -2600, -9000, 3.14159);


            }
            renderer.render(scene, camera);

          }
          if (mixer) {
            var time = Date.now();
            mixer.update((time - prevTime) * 0.001);
            prevTime = time;
          }
        }
      });

      if (action == 'Waving.fbx') {
        animation = 'wave';

      } else {
        animation = 'walk';
      }
      return animation;

    }

    var textMesh;

    function start() {

      const loader5 = new THREE.FontLoader();
      loader5.load('./Open Sans_Italic.json', function (font) {
        const geometry = new THREE.TextGeometry('Enter', {
          font: font,
          size: 50,
          height: 50,
        });
        textMesh = new THREE.Mesh(geometry, [
          new THREE.MeshPhongMaterial({ color: 0xffffff }),
          new THREE.MeshPhongMaterial({ color: 0xffffff })
        ])
        textMesh.castShadow = true;
        textMesh.position.y = 200;
        textMesh.position.z = 950;
        textMesh.position.x = -900;
        textMesh.rotation.y = 0.872665;
        scene.add(textMesh);

      });
    }

















    var prevTime = Date.now();
    function render() {
      if (animation == 'wave') {
        if (mixer) {
          var time = Date.now();
          mixer.update((time - prevTime) * 0.001);
          prevTime = time;
        }
      }


      //console.log(camera.position.z);
      // light.position.x -= 500;
      // light.rotation.z += 0.01;
      // light.position.x += 500;
      renderer.render(scene, camera);
      requestAnimationFrame(render);

    }

    requestAnimationFrame(render);

    //Init our scene

  </script>
</body>

</html>